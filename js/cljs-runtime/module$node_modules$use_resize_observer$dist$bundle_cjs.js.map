{
"version":3,
"file":"module$node_modules$use_resize_observer$dist$bundle_cjs.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/use-resize-observer/dist/bundle.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$use_resize_observer$dist$bundle_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nvar react = require('react');\n\n// This could've been more streamlined with internal state instead of abusing\n// refs to such extent, but then composing hooks and components could not opt out of unnecessary renders.\nfunction useResolvedElement(subscriber, refOrElement) {\n  var lastReportRef = react.useRef(null);\n  var refOrElementRef = react.useRef(null);\n  refOrElementRef.current = refOrElement;\n  var cbElementRef = react.useRef(null); // Calling re-evaluation after each render without using a dep array,\n  // as the ref object's current value could've changed since the last render.\n\n  react.useEffect(function () {\n    evaluateSubscription();\n  });\n  var evaluateSubscription = react.useCallback(function () {\n    var cbElement = cbElementRef.current;\n    var refOrElement = refOrElementRef.current; // Ugly ternary. But smaller than an if-else block.\n\n    var element = cbElement ? cbElement : refOrElement ? refOrElement instanceof Element ? refOrElement : refOrElement.current : null;\n\n    if (lastReportRef.current && lastReportRef.current.element === element && lastReportRef.current.subscriber === subscriber) {\n      return;\n    }\n\n    if (lastReportRef.current && lastReportRef.current.cleanup) {\n      lastReportRef.current.cleanup();\n    }\n\n    lastReportRef.current = {\n      element: element,\n      subscriber: subscriber,\n      // Only calling the subscriber, if there's an actual element to report.\n      // Setting cleanup to undefined unless a subscriber returns one, as an existing cleanup function would've been just called.\n      cleanup: element ? subscriber(element) : undefined\n    };\n  }, [subscriber]); // making sure we call the cleanup function on unmount\n\n  react.useEffect(function () {\n    return function () {\n      if (lastReportRef.current && lastReportRef.current.cleanup) {\n        lastReportRef.current.cleanup();\n        lastReportRef.current = null;\n      }\n    };\n  }, []);\n  return react.useCallback(function (element) {\n    cbElementRef.current = element;\n    evaluateSubscription();\n  }, [evaluateSubscription]);\n}\n\n// We're only using the first element of the size sequences, until future versions of the spec solidify on how\n// exactly it'll be used for fragments in multi-column scenarios:\n// From the spec:\n// > The box size properties are exposed as FrozenArray in order to support elements that have multiple fragments,\n// > which occur in multi-column scenarios. However the current definitions of content rect and border box do not\n// > mention how those boxes are affected by multi-column layout. In this spec, there will only be a single\n// > ResizeObserverSize returned in the FrozenArray, which will correspond to the dimensions of the first column.\n// > A future version of this spec will extend the returned FrozenArray to contain the per-fragment size information.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-entry-interface)\n//\n// Also, testing these new box options revealed that in both Chrome and FF everything is returned in the callback,\n// regardless of the \"box\" option.\n// The spec states the following on this:\n// > This does not have any impact on which box dimensions are returned to the defined callback when the event\n// > is fired, it solely defines which box the author wishes to observe layout changes on.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// I'm not exactly clear on what this means, especially when you consider a later section stating the following:\n// > This section is non-normative. An author may desire to observe more than one CSS box.\n// > In this case, author will need to use multiple ResizeObservers.\n// (https://drafts.csswg.org/resize-observer/#resize-observer-interface)\n// Which is clearly not how current browser implementations behave, and seems to contradict the previous quote.\n// For this reason I decided to only return the requested size,\n// even though it seems we have access to results for all box types.\n// This also means that we get to keep the current api, being able to return a simple { width, height } pair,\n// regardless of box option.\nfunction extractSize(entry, boxProp, sizeType) {\n  if (!entry[boxProp]) {\n    if (boxProp === \"contentBoxSize\") {\n      // The dimensions in `contentBoxSize` and `contentRect` are equivalent according to the spec.\n      // See the 6th step in the description for the RO algorithm:\n      // https://drafts.csswg.org/resize-observer/#create-and-populate-resizeobserverentry-h\n      // > Set this.contentRect to logical this.contentBoxSize given target and observedBox of \"content-box\".\n      // In real browser implementations of course these objects differ, but the width/height values should be equivalent.\n      return entry.contentRect[sizeType === \"inlineSize\" ? \"width\" : \"height\"];\n    }\n\n    return undefined;\n  } // A couple bytes smaller than calling Array.isArray() and just as effective here.\n\n\n  return entry[boxProp][0] ? entry[boxProp][0][sizeType] : // TS complains about this, because the RO entry type follows the spec and does not reflect Firefox's current\n  // behaviour of returning objects instead of arrays for `borderBoxSize` and `contentBoxSize`.\n  // @ts-ignore\n  entry[boxProp][sizeType];\n}\n\nfunction useResizeObserver(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Saving the callback as a ref. With this, I don't need to put onResize in the\n  // effect dep array, and just passing in an anonymous function without memoising\n  // will not reinstantiate the hook's ResizeObserver.\n  var onResize = opts.onResize;\n  var onResizeRef = react.useRef(undefined);\n  onResizeRef.current = onResize;\n  var round = opts.round || Math.round; // Using a single instance throughout the hook's lifetime\n\n  var resizeObserverRef = react.useRef();\n\n  var _useState = react.useState({\n    width: undefined,\n    height: undefined\n  }),\n      size = _useState[0],\n      setSize = _useState[1]; // In certain edge cases the RO might want to report a size change just after\n  // the component unmounted.\n\n\n  var didUnmount = react.useRef(false);\n  react.useEffect(function () {\n    didUnmount.current = false;\n    return function () {\n      didUnmount.current = true;\n    };\n  }, []); // Using a ref to track the previous width / height to avoid unnecessary renders.\n\n  var previous = react.useRef({\n    width: undefined,\n    height: undefined\n  }); // This block is kinda like a useEffect, only it's called whenever a new\n  // element could be resolved based on the ref option. It also has a cleanup\n  // function.\n\n  var refCallback = useResolvedElement(react.useCallback(function (element) {\n    // We only use a single Resize Observer instance, and we're instantiating it on demand, only once there's something to observe.\n    // This instance is also recreated when the `box` option changes, so that a new observation is fired if there was a previously observed element with a different box option.\n    if (!resizeObserverRef.current || resizeObserverRef.current.box !== opts.box || resizeObserverRef.current.round !== round) {\n      resizeObserverRef.current = {\n        box: opts.box,\n        round: round,\n        instance: new ResizeObserver(function (entries) {\n          var entry = entries[0];\n          var boxProp = opts.box === \"border-box\" ? \"borderBoxSize\" : opts.box === \"device-pixel-content-box\" ? \"devicePixelContentBoxSize\" : \"contentBoxSize\";\n          var reportedWidth = extractSize(entry, boxProp, \"inlineSize\");\n          var reportedHeight = extractSize(entry, boxProp, \"blockSize\");\n          var newWidth = reportedWidth ? round(reportedWidth) : undefined;\n          var newHeight = reportedHeight ? round(reportedHeight) : undefined;\n\n          if (previous.current.width !== newWidth || previous.current.height !== newHeight) {\n            var newSize = {\n              width: newWidth,\n              height: newHeight\n            };\n            previous.current.width = newWidth;\n            previous.current.height = newHeight;\n\n            if (onResizeRef.current) {\n              onResizeRef.current(newSize);\n            } else {\n              if (!didUnmount.current) {\n                setSize(newSize);\n              }\n            }\n          }\n        })\n      };\n    }\n\n    resizeObserverRef.current.instance.observe(element, {\n      box: opts.box\n    });\n    return function () {\n      if (resizeObserverRef.current) {\n        resizeObserverRef.current.instance.unobserve(element);\n      }\n    };\n  }, [opts.box, round]), opts.ref);\n  return react.useMemo(function () {\n    return {\n      ref: refCallback,\n      width: size.width,\n      height: size.height\n    };\n  }, [refCallback, size.width, size.height]);\n}\n\nmodule.exports = useResizeObserver;\n\n};"],
"names":["shadow$provide","global","require","module","exports","useResolvedElement","subscriber","refOrElement","lastReportRef","react","useRef","refOrElementRef","current","cbElementRef","useEffect","evaluateSubscription","useCallback","cbElement","element","Element","cleanup","undefined","extractSize","entry","boxProp","sizeType","contentRect","useResizeObserver","opts","onResize","onResizeRef","round","Math","resizeObserverRef","_useState","useState","width","height","size","setSize","didUnmount","previous","refCallback","box","instance","ResizeObserver","entries","reportedWidth","reportedHeight","newWidth","newHeight","newSize","observe","unobserve","ref","useMemo"]
}
